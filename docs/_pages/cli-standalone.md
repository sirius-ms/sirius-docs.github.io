---
permalink: /cli-standalone/
title: "Standalone CLI tools"
---
Standalone tools offer additional SIRIUS-related functionalities that fall outside the standard identification workflow.
These tools include configuration tasks, file conversion utilities, and features that may assist with downstream analysis.
They must be executed separately and cannot be integrated into a toolchain.
Each standalone tool comes with its own
help message, which can be accessed by `sirius <TOOLNAME> -h`.


## Custom database tool
The `custom-db` tool enabled the import of custom structure databases from a CSV or TSV (tab-separated), where 
structures are provided in `SMILES` format. Optionally, you can also provide a database `id` and a `name` for the entries. 

```
CN1CCCC1C2=C[N+](=CC=C2)[O-]	id-01	Nicotin
CN1C=NC2=C1C(=O)N(C(=O)N2C)C	id-03	Caffein
CN1CCC2=CC3=C(C=C2C1C4C5=C(C6=C(C=C5)OCO6)C(=O)O4)OCO3 id-05 Bicculine
```

You can import multiple files containing compounds in SMILES format into a single database. If a structure is already present in
SIRIUS' internal structure database, the fingerprint will be downloaded automatically. Otherwise, the fingerprint is computed locally on your computer, 
which may take some time, especially for a large number of structures.


```shell
sirius -i <structure.tsv> custom-db --name myDB --output /some/dir
```

Note, that PubChem standardized SMILES are typically used to represent structures in our machine learning methods. 
However, the PubChem standardization is not integrated into this import process. For optimal results, we recommend standardizing
your SMILES using the PubChem standardization before importing them. This step is **not** mandatory, but recommended.


## Similarity tool
The `similarity` tool allows you to compute different similarity measures between compounds.
It accepts a SIRIUS project-space (or any input format that SIRIUS can convert into a project, such as `.ms`, `.mgf` or `.cef`) 
as input using the `sirius -i <INPUT>` command.
The tool computes all against all similarity matrices for the compounds in
the project-space and saves the results in the specified output directory defined by the `-d` option.

```shell
sirius -i <project-space> similarity --cosine --ftalign --ftblast <SPECTRA_LIB> --tanimoto -d <OUTPUT>
```

### Cosine Similarity   (`--cosine`)
This option computes the cosine similarity of the merged MS/MS spectra between all compounds in the dataset.
It requires only the spectra, so no additional preprocessing is needed.

### Fragmentation Tree alignment Similarity  (`--ftalign`)
This option computes the tree alignment score between the top ranked fragmentation trees of all compounds.
For this computation, the input project-space must already contain the fragmentation trees generated by the `formula` subtool of the [SIRIUS CLI]({{ "/cli/" | relative_url }}). So the `formula` subtool must be executed beforehand. 

### FT-Blast (`--ftblast`)
This option aligns the fragmentation tree of the compounds in the dataset against a library of fragmentation trees. 
The input project-space must already contain fragmentation trees computed with the `formula` subtool of the [SIRIUS CLI]({{ "/cli/" | relative_url }}).
So the `formula` subtool must be executed beforehand. The fragmentation tree library (`--ft-blast=<LIB_PATH>`) can either be another
SIRIUS project-space containing fragmentation trees, or a directory containing fragmentation trees in JSON format.
The alignment method is described by [Rasche *et al.*](https://doi.org/10.1021/ac300304u)

### Tanimoto Similarity (`--tanimoto`)
This option computes the Tanimoto similarity between the top-ranked predicted fingerprints of all compounds in the dataset.
The input project-space must already contain the predicted fingerprints generated by the `structure` subtool of the [SIRIUS CLI]({{ "/cli/" | relative_url }}).
So both the `formula` and `structure` subtools must be executed beforehand.
Note that the fingerprints being compared are probabilistic. The Tanimoto similarity
between two probabilistic fingerprints, 
$F$ and $F'$, of length $n$ is computed as follows:

$$\frac{ \sum_{i=1}^{n} F_i \cdot F'_i } { \sum_{i=1}^{n} 1 - (1 - F_i) \cdot (1 - F'_i) }$$

### Examples

**Example 1:**
To compute  `--cosine`, `--ftalign`  and `--tanimoto` similarities, we first need a project-space
that contains spectra, fragmetations trees and fingerprints. We generate these with the following command:
```shell
sirius -i <input-data.mgf> -o <my-project> formula structure
```

This command processes the input data to create the necessary project-space (`my-project`). 
Once this project-space is created, it can be used as input for the similarity computation:
```shell
sirius -i <my-project> similarity --cosine --ftalign --tanimoto --d <output-dir>
```

**Example 2:**
To compute `--ftblast` similarities, we first need a project-space (`my-project`)
that contains fragmentation trees computed from our input spectral data and another project-space (`library-project`) that contains a fragmentation tree library, e.g. computed from a spectral library. 
Assuming both the input and library spectra are in [MGF format]({{ "/io/#mgf-format" | relative_url }}), we have to execute 
the following commands.

Compute fragmentation trees for the input data:
```shell
sirius -i <input-data.mgf> -o <my-project> sirius
```

Compute fragmentation trees for the library spectra:
```shell
sirius -i <library-data.mgf> -o <library-project> sirius
```

No that both project-spaces are prepared, we can proceed with the `--ftblast` similarity computation:
```shell
sirius -i <my-project> similarity --ftblast <library-project> -d <output-dir>
```


## Mass Decomposition tool
The `decomp` tool provides the SIRIUS internal [efficient mass decomposition 
algorithm by Böcker and Lipták](https://doi.org/10.1145/1066677.1066715) as standalone tool to decompose masses with given deviation, ionization, chemical alphabet and chemical filter.

## MGF export tool
The `mgf-export` tool exports the spectra from a given project-space as [MGF file]({{ "/io/#mgf-format" | relative_url }}) for use with other tools, such as [GNPS](https://gnps.ucsd.edu/ProteoSAFe/static/gnps-splash.jsp).
The `--quant-table` option allows to export an additional feature quantification table in CSV format,
e.g. for [GNPS Feature-Based Molecular Networking](https://ccms-ucsd.github.io/GNPSDocumentation/featurebasedmolecularnetworking/):
```shell
sirius --input <project-space> MGF --merge-ms2 --quant-table <table.csv> --output <spectra.mgf>
```
Please not that quantification information is only available if the source of the project-space was in `.mzml` or `.mzxml` format.

## Fragmentation tree export tool {#ftree-export}
The `ftree-export` tool exports the fragmentation trees from a given project-space (`sirius -i <INPUT>`) in
various formats (`--json`, `--dot`) to a specified output directory (`--output <DIR>`). The `--all` option lets you choose whether to export
 fragmentation trees of *all* formula candidates of a compound or only the top-ranked candidate.

For example, to export the top-ranked fragmentation tree of all compounds in the project-space in `dot` format, you would use:
```shell
sirius --input <project-space> ftree-export --dot --output <output-dir>
```

You can convert `.dot` files into various image formats (e.g., PDF, SVG, PNG) using 
the commandline tool [Graphviz](https://www.graphviz.org/).
After [installing Graphviz](https://graphviz.org/download/) you can create a PDF file from a `.dot` file with the following command:

```shell
dot -Tpdf <tree-file.dot> > <tree-file.pdf>
```

{% capture fig_img %}
![Foo]({{ "/assets/images/bicculine_frag_tree.svg" | relative_url }})
{% endcapture %}

<figure>
  {{ fig_img | markdownify | remove: "<p>" | remove: "</p>" }}
  <figcaption>Fragmentation Tree exported as `.dot` and converted to `.svg`.</figcaption>
</figure>

Please note that the [SIRIUS GUI]({{ "/gui/#formulas-tab" | relative_url }}) allows you to directly export the rendered 
tree as vector or pixel graphics. 

## Project-space tool
The `project-space` tool modifies a given project-space by allowing operations such as merging, splitting, filtering, and version conversion. 
Read project(s) with `--input`, apply the desired modifications and specify the output with `--output`. If you provide only `--input` or `--output`, the modifications will be made in-place.